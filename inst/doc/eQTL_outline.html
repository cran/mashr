<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1">

<meta name="author" content="Matthew Stephens" />

<meta name="date" content="2020-06-17" />

<title>eQTL analysis outline</title>



<style type="text/css">code{white-space: pre;}</style>
<style type="text/css" data-origin="pandoc">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(data-line-number);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */

</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    for (var j = 0; j < rules.length; j++) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") continue;
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') continue;
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>



<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#header {
text-align: center;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; }  code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">eQTL analysis outline</h1>
<h4 class="author">Matthew Stephens</h4>
<h4 class="date">2020-06-17</h4>



<div id="introduction" class="section level1">
<h1>Introduction</h1>
<p>In the introductory <code>mashr</code> vignettes we assumed that the data were small enough that it was convenient to read them all in and do all the analyses on the same data.</p>
<p>In larger applications, particularly eQTL studies, it can be more convenient to do different parts of the analyses on subsets of the tests. Specifically, if you have millions of tests in dozens of conditions, it might be helpful to consider subsets of these millions of tests at any one time. Here we illustrate this idea.</p>
<p>Our suggested workflow is to extract (at least) two subsets of tests from your complete data set:</p>
<ol style="list-style-type: decimal">
<li><p>Results from a subset of “strong” tests corresponding to stronger effects in your study. For example, these tests might have been identified by taking the “top” eQTL in each gene based on univariate test results, or by some other approach such as a simple meta-analysis.</p></li>
<li><p>Results from a <em>random subset</em> of all tests. It is important that these be an unbiased representation of all the tests you are considering, including null and non-null tests, because <code>mashr</code> uses these tests to learn about the amount of signal in the data, and to “correct” estimates for the fact that many tests are null (analagous to a kind of multiple testing correction.)</p></li>
</ol>
<p>We will call the data from these two sets of tests <code>strong</code> and <code>random</code> respectively.</p>
<p>To give some sense of the potential appropriate sizes of these datasets: in our eQTL application in <a href="https://www.biorxiv.org/content/early/2017/05/09/096552">Urbut et al</a>, the <code>strong</code> data contained about 16k tests (the top eQTL per gene), and for the <code>random</code> data we used 20k randomly-selected tests. (If you suspect true effects are very sparse then you might want to increase the size of the random subset, say to 200k).</p>
<div id="analysis-strategy-outline" class="section level2">
<h2>Analysis strategy outline</h2>
<p>The basic analysis strategy is now:</p>
<ol style="list-style-type: decimal">
<li><p>Learn correlation structure among null tests using <code>random</code> test.</p></li>
<li><p>Learn data-driven covariance matrices using <code>strong</code> tests.</p></li>
<li><p>Fit the mashr model to the <code>random</code> tests, to learn the mixture weights on all the different covariance matrices and scaling coefficients.</p></li>
<li><p>Compute posterior summaries on the <code>strong</code> tests, using the model fit from step 2. (At this stage you could actually compute posterior summaries for any sets of tests you like. For example you could read in all your tests in small batches and compute posterior summaries in batches. But for illustration we will just do it on the <code>strong</code> tests.)</p></li>
</ol>
</div>
</div>
<div id="example" class="section level1">
<h1>Example</h1>
<p>First we simulate some data to illustrate the ideas. To make this convenient to run we simulate a small data. And we identify the strong hits using <code>mash_1by1</code>. But in practice you may want to use methods outside of R to extract the matrices of data corresponding to strong and random tests, and then read them in as you need them. For example, see <a href="https://github.com/stephenslab/gtexresults/blob/master/workflows/fastqtl_to_mash.ipynb">here</a> for scripts we use for processing fastQTL output.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">library</span>(ashr)</a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="kw">library</span>(mashr)</a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="kw">set.seed</span>(<span class="dv">1</span>)</a>
<a class="sourceLine" id="cb1-4" data-line-number="4">simdata =<span class="st"> </span><span class="kw">simple_sims</span>(<span class="dv">10000</span>,<span class="dv">5</span>,<span class="dv">1</span>) <span class="co"># simulates data on 40k tests</span></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"></a>
<a class="sourceLine" id="cb1-6" data-line-number="6"><span class="co"># identify a subset of strong tests</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7">m<span class="fl">.1</span>by1 =<span class="st"> </span><span class="kw">mash_1by1</span>(<span class="kw">mash_set_data</span>(simdata<span class="op">$</span>Bhat,simdata<span class="op">$</span>Shat))</a>
<a class="sourceLine" id="cb1-8" data-line-number="8">strong.subset =<span class="st"> </span><span class="kw">get_significant_results</span>(m<span class="fl">.1</span>by1,<span class="fl">0.05</span>)</a>
<a class="sourceLine" id="cb1-9" data-line-number="9"></a>
<a class="sourceLine" id="cb1-10" data-line-number="10"><span class="co"># identify a random subset of 5000 tests</span></a>
<a class="sourceLine" id="cb1-11" data-line-number="11">random.subset =<span class="st"> </span><span class="kw">sample</span>(<span class="dv">1</span><span class="op">:</span><span class="kw">nrow</span>(simdata<span class="op">$</span>Bhat),<span class="dv">5000</span>)</a></code></pre></div>
<div id="correlation-structure" class="section level2">
<h2>Correlation structure</h2>
<p>We estimate the correlation structure in the null tests from the <code>random</code> data (not the <code>strong</code> data because they will not necessarily contain any null tests).</p>
<p>To do this we set up a temporary data object <code>data.temp</code> from the random tests and use <code>estimate_null_correlation_simple</code> as in <a href="intro_correlations.html">this vignette</a>.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb2-1" data-line-number="1">data.temp =<span class="st"> </span><span class="kw">mash_set_data</span>(simdata<span class="op">$</span>Bhat[random.subset,],simdata<span class="op">$</span>Shat[random.subset,])</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">Vhat =<span class="st"> </span><span class="kw">estimate_null_correlation_simple</span>(data.temp)</a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="kw">rm</span>(data.temp)</a></code></pre></div>
<p>Now we can set up our main data objects with this correlation structure in place:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3-1" data-line-number="1">data.random =<span class="st"> </span><span class="kw">mash_set_data</span>(simdata<span class="op">$</span>Bhat[random.subset,],simdata<span class="op">$</span>Shat[random.subset,],<span class="dt">V=</span>Vhat)</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">data.strong =<span class="st"> </span><span class="kw">mash_set_data</span>(simdata<span class="op">$</span>Bhat[strong.subset,],simdata<span class="op">$</span>Shat[strong.subset,], <span class="dt">V=</span>Vhat)</a></code></pre></div>
</div>
<div id="data-driven-covariances" class="section level2">
<h2>Data driven covariances</h2>
<p>Now we use the strong tests to set up data-driven covariances.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb4-1" data-line-number="1">U.pca =<span class="st"> </span><span class="kw">cov_pca</span>(data.strong,<span class="dv">5</span>)</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">U.ed =<span class="st"> </span><span class="kw">cov_ed</span>(data.strong, U.pca)</a></code></pre></div>
</div>
<div id="fit-mash-model-estimate-mixture-proportions" class="section level2">
<h2>Fit mash model (estimate mixture proportions)</h2>
<p>Now we fit mash to the random tests using both data-driven and canonical covariances. (Remember the Crucial Rule! We have to fit using a random set of tests, and not a dataset that is enriched for strong tests.) The <code>outputlevel=1</code> option means that it will not compute posterior summaries for these tests (which saves time).</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb5-1" data-line-number="1">U.c =<span class="st"> </span><span class="kw">cov_canonical</span>(data.random)</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">m =<span class="st"> </span><span class="kw">mash</span>(data.random, <span class="dt">Ulist =</span> <span class="kw">c</span>(U.ed,U.c), <span class="dt">outputlevel =</span> <span class="dv">1</span>)</a></code></pre></div>
<pre><code>#  - Computing 5000 x 241 likelihood matrix.
#  - Likelihood calculations took 0.20 seconds.
#  - Fitting model with 241 mixture components.
#  - Model fitting took 4.23 seconds.</code></pre>
</div>
<div id="compute-posterior-summaries" class="section level2">
<h2>Compute posterior summaries</h2>
<p>Now we can compute posterior summaries etc for any subset of tests using the above mash fit. Here we do this for the <code>strong</code> tests. We do this using the same <code>mash</code> function as above, but we specify to use the fit from the previous run of mash by specifying<br />
<code>g=get_fitted_g(m), fixg=TRUE</code>. (In <code>mash</code> the parameter <code>g</code> is used to denote the mixture model which we learned above.)</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb7-1" data-line-number="1">m2 =<span class="st"> </span><span class="kw">mash</span>(data.strong, <span class="dt">g=</span><span class="kw">get_fitted_g</span>(m), <span class="dt">fixg=</span><span class="ot">TRUE</span>)</a></code></pre></div>
<pre><code>#  - Computing 1428 x 241 likelihood matrix.
#  - Likelihood calculations took 0.05 seconds.
#  - Computing posterior matrices.
#  - Computation allocated took 0.01 seconds.</code></pre>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">head</span>(<span class="kw">get_lfsr</span>(m2))</a></code></pre></div>
<pre><code>#               condition_1  condition_2  condition_3  condition_4  condition_5
# effect_13096 9.837638e-06 5.072688e-01 4.242991e-01 3.957421e-01 6.073757e-01
# effect_29826 6.567291e-05 6.639266e-01 5.839528e-01 6.359974e-01 5.770477e-01
# effect_14042 6.994599e-02 6.496975e-03 2.483998e-03 5.562658e-02 6.838122e-06
# effect_12524 1.119205e-01 4.107521e-01 2.985498e-02 2.578507e-05 1.001811e-01
# effect_15456 4.911825e-05 4.382090e-01 2.735423e-01 5.167374e-01 3.611055e-01
# effect_35844 2.619621e-09 4.563744e-09 1.862051e-07 1.012529e-09 4.090084e-11</code></pre>
</div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
